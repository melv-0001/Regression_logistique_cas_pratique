# ========================================
# üìä Classification binaire : Croissance de population en C√¥te d'Ivoire
# Objectif : pr√©dire si une r√©gion conna√Æt une croissance rapide (1) ou normale (0)
# ========================================

# ‚úÖ 1. Importation des biblioth√®ques n√©cessaires
import numpy as np                # Pour les calculs num√©riques
import pandas as pd              # Pour manipuler les tableaux de donn√©es (DataFrames)
from sklearn.model_selection import train_test_split  # Pour diviser les donn√©es en train/test
from sklearn.linear_model import LogisticRegression   # Mod√®le de r√©gression logistique
from sklearn.metrics import (    # Outils pour √©valuer les performances du mod√®le
    confusion_matrix, accuracy_score, precision_score,
    recall_score, f1_score, roc_curve, auc
)
import matplotlib.pyplot as plt  # Pour les graphiques
import seaborn as sns            # Pour des graphiques plus esth√©tiques (ex: heatmap)

# ‚úÖ 2. G√©n√©ration de donn√©es simul√©es (fictives mais r√©alistes)

# On fixe une graine al√©atoire pour avoir toujours les m√™mes r√©sultats
np.random.seed(0)

# Nombre d'observations (r√©gions ou localit√©s en C√¥te d‚ÄôIvoire par exemple)
n = 200

# Cr√©ation de 4 variables ind√©pendantes avec des valeurs r√©alistes
X = pd.DataFrame({
    'taux_natalite': np.random.normal(35, 5, n),           # Moyenne = 35 naissances / 1000 hab
    'migration_nette': np.random.normal(2, 3, n),          # Entr√©e/sortie de population
    'taux_alphabetisation': np.random.normal(60, 10, n),   # En pourcentage (%)
    'urbanisation': np.random.normal(50, 15, n)            # Taux d‚Äôurbanisation en %
})

# ‚úÖ 3. G√©n√©ration de la variable cible `y` (croissance rapide = 1 / normale = 0)
# Hypoth√®se : une r√©gion avec une forte natalit√© (>37) et faible alphab√©tisation (<65) ‚Üí croissance rapide
y = ((X['taux_natalite'] > 37) & (X['taux_alphabetisation'] < 65)).astype(int)

# ‚úÖ 4. Division des donn√©es en train (70%) et test (30%)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

# ‚úÖ 5. Cr√©ation et entra√Ænement du mod√®le de classification
model = LogisticRegression()      # On choisit une r√©gression logistique (mod√®le binaire)
model.fit(X_train, y_train)       # Entra√Ænement sur les donn√©es d‚Äôapprentissage

# ‚úÖ 6. Pr√©diction sur les donn√©es de test
y_pred = model.predict(X_test)                  # Classe pr√©dite (0 ou 1)
y_proba = model.predict_proba(X_test)[:, 1]     # Probabilit√© d‚Äôappartenir √† la classe 1 (croissance rapide)

# ‚úÖ 7. √âvaluation des performances du mod√®le

# Matrice de confusion : compare les vrais r√©sultats aux pr√©dictions
conf_mat = confusion_matrix(y_test, y_pred)

# Accuracy : proportion de bonnes pr√©dictions
accuracy = accuracy_score(y_test, y_pred)

# Pr√©cision : parmi les "croissances rapides" pr√©dites, combien sont correctes ?
precision = precision_score(y_test, y_pred)

# Rappel : parmi les vraies croissances rapides, combien sont d√©tect√©es ?
recall = recall_score(y_test, y_pred)

# F1-score : moyenne harmonique entre pr√©cision et rappel
f1 = f1_score(y_test, y_pred)

# ‚úÖ 8. Affichage des m√©triques dans la console
print("üìä Matrice de confusion :\n", conf_mat)
print(f"\nüéØ Exactitude (Accuracy) : {accuracy:.2f}")
print(f"‚úÖ Pr√©cision : {precision:.2f}")
print(f"üîÅ Rappel : {recall:.2f}")
print(f"üìå F1-score : {f1:.2f}")

# ‚úÖ 9. Calcul des donn√©es pour la courbe ROC
# ROC : montre comment le mod√®le s√©pare les classes √† diff√©rents seuils
fpr, tpr, thresholds = roc_curve(y_test, y_proba)
roc_auc = auc(fpr, tpr)  # AUC = Aire sous la courbe ROC (entre 0.5 et 1.0)

# ‚úÖ 10. Affichage graphique (visualisation des r√©sultats)
plt.figure(figsize=(12, 5))  # Taille de la figure

# üé® Sous-graphique 1 : Matrice de confusion
plt.subplot(1, 2, 1)
sns.heatmap(conf_mat, annot=True, fmt='d', cmap="Blues")
plt.title("Matrice de confusion")
plt.xlabel("Valeurs Pr√©dites")
plt.ylabel("Valeurs R√©elles")

# üé® Sous-graphique 2 : Courbe ROC
plt.subplot(1, 2, 2)
plt.plot(fpr, tpr, color='darkorange', lw=2, label=f"AUC = {roc_auc:.2f}")
plt.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--')  # Diagonale (mod√®le al√©atoire)
plt.title("Courbe ROC")
plt.xlabel("Taux de Faux Positifs (FPR)")
plt.ylabel("Taux de Vrais Positifs (TPR)")
plt.legend(loc="lower right")
plt.grid(True)

plt.tight_layout()  # Ajuste l‚Äôespacement entre les sous-graphiques
plt.show()          # Affiche la figure compl√®te
